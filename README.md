# lesson60-61
Болкарева Анна

1-Функция, как и процедура, это вспомогательный алгоритм, который может принимать параметры. Но, в отличие от процедуры, функция всегда возвращает значение-результат. Результатом может быть число, символ, символьная строка или данные другого типа

2-Оба языка объявляют функцию, возвращают и позволяют делать похожие друг на друга команды в функции, однако Паскаль является более сложным языком, в отличие от школьного алгоритмического, и может выполнять больше команд

3-Эта функция возвращает логическое значение, на это указывает ключевое слово лог (в Паскале boolean). Значение функции определяется как;

знач: (count=0) 

Это оператор присваивания. Слева от знака: записана логическая переменная, а справа логическое выражение (условие). Если это выражение истинно, то в переменную знач записывается значение да, иначе значение нет.

4-Логическая функция – это логическая зависимая переменная от одной или нескольких логических переменных. Логические функции можно использовать так же, как и лю бые условия: в условных операторах и циклах с условием.

Задачи

1-if (a > b):

 m = a
 
else:

 m = b
 
if c > m:

 m = c

2-float f(float a,b,c)

{

if (a>b)

 if (a>c)
 
 return a;
 
 else return b;
 
else if (b>c)

return b;

 else return c;
 
 }

3-function DigitCount(n:Cardinal):integer;

begin
DigitCount:=Trunc(ln(n)/ln(10))+1;

end;

4-import mathval1 = int(input("клавиатура:"))

val2 = int(input("клавиатура:"))

print("НОК:"math.lcm(val1,val2))

print("НОД",math.gcd(val1,val2))

5-def lcm(a,b): m = a*b

 while a != 0 and b != 0: if a > b:
 
 a %= b else:
 
 b %= a return m // (a+b)
 
while 1:

 try: x = int(input('a='))
 
 y = int(input('b=')) print('НОК:',lcm(x,y))
 
 except: break

6-int revNum(int n)

{

   int a=0;
    
  while(n)
    
  {
  
   a=a*10+n%10;
        
  n=n/10;
  
  }
  
  return a;
  
}

7-#include <iostream>
 
using namespace std;
 
    
int main()
{
    int arr[11] = {0};
 
 
   for(int i=0;i<36000;++i)
        ++arr[rand()%6 + rand()%6];
    
    
 
   for(int i=0;i<11;++i)
        cout<<arr[i]<<"   ";
    cout<<endl;
 
   system("PAUSE");
    return 0;
}

8-def factorial(n):

  res = 1
    
  for i in range(1,n+1):
    
  res*=i
        
  return res
 
n = None

while type(n) != int:

  try:
    
  n = int(input('N = '))
        
   print(factorial(n))
        
  except:
    
  print('Введено не число, либо не целое число! Попробуйте ещё раз')


9-#include <iostream>
 
using namespace std;
 
int f(int n)

{

  int a = 0;
    
  int b = 1;
    
  for (int i = 0; i < n; i++)
    
  {
    
   a = a + b;
        
  b = a - b;
        
  }
  
return a;

}
 
int main()

{

  int n;
  
   cin >> n;
   
  cout << f(n) << "\n";
  
   system("pause");
   
  return 0;
  
}


10-max_number = 10000
 

def summa(n):

  сумма = 0
    
  for k in range(1, n//2+1):
  
  if n%k == 0:
    
  сумма += k
       
  return сумма
 

lst = [0, 1]

for m in range(2, max_number+1):

  1st.append(summa(m))
 

for i in range(2, max_number+1):

  for j in range(i+1, max_number+1):
    
  if i == lst[j] and j == lst[i]:
        
  print(i, j)


11-[i for i in range(N+1) if sum_gidits(i)==sum_digits(i*2)]

12-def is_perf(n):

  s=1
    
  for i in range(2,n//2):
    
  if i*i>n : break
        
  if n%i==0 :
        
   s+=i
            
  s+=n//i
            
return s==n
    
a=int(input())

b=int(input())
 
for x in range(a,b+1):

  if is_perf(x) : print(x)


13-def isPrime(n):

  if (n<=2):
    
   return True
        
if n%2==0:
    
  return False
        
else:
    
  k=3
        
  while(k<n//2):
        
   if (n%k)==0:
            
   return False
                
   k+=2
            
   return True
        
def isHyperPrime(n):

 if not isPrime(n):
         
  return False
        
 else:
    
   while(True):
        
   if (n==0):
            
  break
                
   n=n//10
            
  if not isPrime(n):
            
   return False
                
  return True
        
n=int(input())

if isHyperPrime(n):

print("Число гиперпростое")

else:

if isPrime(n):
    
   print("Число простое, но не гиперпростое")
        
  else:
  
 print("Число составное")

#61

1-Рекурсия - это способ определения множества объектов через само это множество на основе заданных простых базовых случаев. Пр: числа Фибоначчи, фракталы

2-Первая часть в определении натуральных чисел это и есть тот самый базовый случай. Если убрать первую часть из определения, оно будет неполно: вторая часть даёт только метод перехода к следующему значению, но не даёт никакой «зацепки», не отвечает на вопрос «откуда начать»

3-Рекурсивная процедура (функция) - это процедура (функция), которая вызывает сама себя напрямую или через другие процедуры и функции

4-"Ханойская башня" является одной из популярных головоломок XIX века. Даны три стержня, на один из которых нанизаны восемь колец, причем кольца отличаются размером и лежат меньшее на большем. Задача состоит в том, чтобы перенести пирамиду из восьми колец за наименьшее число ходов на другой стержень. За один раз разрешается переносить только одно кольцо, причём нельзя класть большее кольцо на меньшее. Решить эту задачу можно было и помощью цикла. Поэтому можно сделать важный вывод: рекурсия заменяет цикл. При этом программа, как правило, становится более понятной

5-Б, т.к. Эта процедура вызывает сама себя, но с другими значениями параметров. Такая процедура называется рекурсивной

6-При отсуствиии условия выхода функция зациклится и будет выполняться бесконечно

7-Стек (англ. stack кипа, стопка) - особая область памяти, в которой хранятся локальные переменные и адреса возврата из процедур и функций

8-При вызове процедуры в стек помещаются значения всех её параметров, адрес возврата и выделяется место под локальные переменные, поэтому если функция вызывает саму себя слишком много раз, то каждый новый вызов функции добавляет новый элемент в стек. Если глубина рекурсии слишком большая, то стек может переполниться

9-недостаток - требования к размеру стека;

Преимущество - некоторые алгоритмы многократно проще, короче и понятнее записать в рекурсивном виде, чем через циклы

Задачи

1-

2-

3-

4-

5-

6-
